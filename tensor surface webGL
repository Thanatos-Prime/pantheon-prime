<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tensor-Surface WebGL - 3D Clustering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        color: #fff;
        overflow: hidden;
    }
    
    #container {
        display: flex;
        height: 100vh;
    }
    
    #canvas-container {
        flex: 1;
        position: relative;
    }
    
    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
    
    #controls {
        width: 320px;
        background: rgba(20, 20, 40, 0.95);
        padding: 20px;
        overflow-y: auto;
        border-left: 2px solid #4a5568;
    }
    
    .control-group {
        margin-bottom: 25px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .control-group h3 {
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 15px;
        color: #60a5fa;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .control-row {
        margin-bottom: 12px;
    }
    
    label {
        display: block;
        font-size: 12px;
        color: #9ca3af;
        margin-bottom: 6px;
    }
    
    input[type="range"] {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 14px;
        height: 14px;
        background: #60a5fa;
        border-radius: 50%;
        cursor: pointer;
    }
    
    select, button {
        width: 100%;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        border-radius: 6px;
        cursor: pointer;
        font-size: 13px;
    }
    
    button {
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        font-weight: 600;
        transition: transform 0.2s;
    }
    
    button:hover {
        transform: translateY(-2px);
    }
    
    .value-display {
        display: inline-block;
        float: right;
        font-weight: 600;
        color: #60a5fa;
    }
    
    #stats {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .stat-row {
        display: flex;
        justify-content: space-between;
        margin: 4px 0;
    }
    
    .stat-label {
        color: #9ca3af;
        margin-right: 15px;
    }
    
    .stat-value {
        color: #60a5fa;
        font-weight: bold;
    }
    
    .cluster-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }
    
    .cluster-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
    }
    
    .cluster-color {
        width: 12px;
        height: 12px;
        border-radius: 3px;
    }
</style>
```

</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="webgl-canvas"></canvas>
            <div id="stats">
                <div class="stat-row">
                    <span class="stat-label">Points:</span>
                    <span class="stat-value" id="point-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Clusters:</span>
                    <span class="stat-value" id="cluster-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">FPS:</span>
                    <span class="stat-value" id="fps">60</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Algorithm:</span>
                    <span class="stat-value" id="algo-name">K-Means</span>
                </div>
            </div>
        </div>

```
    <div id="controls">
        <h2 style="margin-bottom: 20px; font-size: 20px;">‚ö° Tensor-Surface</h2>
        
        <div class="control-group">
            <h3>üé≤ Dataset</h3>
            <div class="control-row">
                <label>Dataset Type</label>
                <select id="dataset-type">
                    <option value="gaussian">Gaussian Blobs</option>
                    <option value="spiral">Spiral</option>
                    <option value="sphere">Sphere Surface</option>
                    <option value="swiss-roll">Swiss Roll</option>
                </select>
            </div>
            <div class="control-row">
                <label>
                    Points
                    <span class="value-display" id="points-value">500</span>
                </label>
                <input type="range" id="points-slider" min="100" max="2000" step="100" value="500">
            </div>
            <div class="control-row">
                <button id="regenerate-btn">üîÑ Regenerate Data</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>üßÆ Clustering</h3>
            <div class="control-row">
                <label>Algorithm</label>
                <select id="cluster-algo">
                    <option value="kmeans">K-Means</option>
                    <option value="hierarchical">Hierarchical</option>
                </select>
            </div>
            <div class="control-row">
                <label>
                    Clusters (k)
                    <span class="value-display" id="k-value">3</span>
                </label>
                <input type="range" id="k-slider" min="2" max="10" step="1" value="3">
            </div>
            <div class="control-row">
                <button id="cluster-btn">‚ñ∂Ô∏è Run Clustering</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>üé® Visualization</h3>
            <div class="control-row">
                <label>
                    Point Size
                    <span class="value-display" id="size-value">0.03</span>
                </label>
                <input type="range" id="size-slider" min="0.01" max="0.1" step="0.01" value="0.03">
            </div>
            <div class="control-row">
                <label>
                    Rotation Speed
                    <span class="value-display" id="rotation-value">0.5</span>
                </label>
                <input type="range" id="rotation-slider" min="0" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-row">
                <label>Show Centroids</label>
                <select id="centroids-toggle">
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                </select>
            </div>
        </div>
        
        <div class="control-group">
            <h3>üìä Cluster Legend</h3>
            <div id="cluster-legend" class="cluster-legend"></div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // ====================================================================
    // SCENE SETUP
    // ====================================================================
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    
    const canvas = document.getElementById('webgl-canvas');
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;
    
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth - 320, window.innerHeight);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);
    
    // ====================================================================
    // DATA GENERATION
    // ====================================================================
    
    function generateGaussianBlobs(n, k) {
        const points = [];
        const perCluster = Math.floor(n / k);
        
        for (let c = 0; c < k; c++) {
            const center = [
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            ];
            
            for (let i = 0; i < perCluster; i++) {
                points.push([
                    center[0] + (Math.random() - 0.5) * 0.5,
                    center[1] + (Math.random() - 0.5) * 0.5,
                    center[2] + (Math.random() - 0.5) * 0.5
                ]);
            }
        }
        return points;
    }
    
    function generateSpiral(n) {
        const points = [];
        for (let i = 0; i < n; i++) {
            const t = (i / n) * 4 * Math.PI;
            const r = t / (4 * Math.PI);
            points.push([
                r * Math.cos(t),
                r * Math.sin(t),
                (i / n - 0.5) * 2
            ]);
        }
        return points;
    }
    
    function generateSphere(n) {
        const points = [];
        for (let i = 0; i < n; i++) {
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            points.push([
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ]);
        }
        return points;
    }
    
    function generateSwissRoll(n) {
        const points = [];
        for (let i = 0; i < n; i++) {
            const t = (i / n) * 3 * Math.PI;
            const h = (Math.random() - 0.5) * 2;
            points.push([
                t * Math.cos(t) / 10,
                h,
                t * Math.sin(t) / 10
            ]);
        }
        return points;
    }
    
    // ====================================================================
    // CLUSTERING ALGORITHMS
    // ====================================================================
    
    function kMeans(points, k, maxIter = 100) {
        // Initialize centroids randomly
        let centroids = [];
        for (let i = 0; i < k; i++) {
            centroids.push([...points[Math.floor(Math.random() * points.length)]]);
        }
        
        let assignments = new Array(points.length).fill(0);
        
        for (let iter = 0; iter < maxIter; iter++) {
            // Assign points to nearest centroid
            for (let i = 0; i < points.length; i++) {
                let minDist = Infinity;
                let bestCluster = 0;
                
                for (let c = 0; c < k; c++) {
                    const dist = euclideanDist(points[i], centroids[c]);
                    if (dist < minDist) {
                        minDist = dist;
                        bestCluster = c;
                    }
                }
                assignments[i] = bestCluster;
            }
            
            // Update centroids
            const newCentroids = Array(k).fill(null).map(() => [0, 0, 0]);
            const counts = new Array(k).fill(0);
            
            for (let i = 0; i < points.length; i++) {
                const c = assignments[i];
                newCentroids[c][0] += points[i][0];
                newCentroids[c][1] += points[i][1];
                newCentroids[c][2] += points[i][2];
                counts[c]++;
            }
            
            for (let c = 0; c < k; c++) {
                if (counts[c] > 0) {
                    centroids[c] = [
                        newCentroids[c][0] / counts[c],
                        newCentroids[c][1] / counts[c],
                        newCentroids[c][2] / counts[c]
                    ];
                }
            }
        }
        
        return { assignments, centroids };
    }
    
    function euclideanDist(p1, p2) {
        return Math.sqrt(
            (p1[0] - p2[0]) ** 2 +
            (p1[1] - p2[1]) ** 2 +
            (p1[2] - p2[2]) ** 2
        );
    }
    
    // ====================================================================
    // VISUALIZATION
    // ====================================================================
    
    const clusterColors = [
        0xff6b6b, 0x4ecdc4, 0xffe66d, 0xa8e6cf, 
        0xff8b94, 0x95e1d3, 0xf38181, 0xaa96da,
        0xfcbad3, 0xa8dadc
    ];
    
    let pointsMesh;
    let centroidsMesh;
    let currentData = [];
    let currentAssignments = [];
    let currentCentroids = [];
    
    function visualizePoints(points, assignments, centroids, pointSize, showCentroids) {
        // Clear existing
        if (pointsMesh) scene.remove(pointsMesh);
        if (centroidsMesh) scene.remove(centroidsMesh);
        
        // Create points
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(points.length * 3);
        const colors = new Float32Array(points.length * 3);
        
        for (let i = 0; i < points.length; i++) {
            positions[i * 3] = points[i][0];
            positions[i * 3 + 1] = points[i][1];
            positions[i * 3 + 2] = points[i][2];
            
            const cluster = assignments[i] || 0;
            const color = new THREE.Color(clusterColors[cluster % clusterColors.length]);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: pointSize,
            vertexColors: true,
            sizeAttenuation: true
        });
        
        pointsMesh = new THREE.Points(geometry, material);
        scene.add(pointsMesh);
        
        // Create centroids
        if (showCentroids && centroids && centroids.length > 0) {
            const centroidGeometry = new THREE.BufferGeometry();
            const centroidPositions = new Float32Array(centroids.length * 3);
            const centroidColors = new Float32Array(centroids.length * 3);
            
            for (let i = 0; i < centroids.length; i++) {
                centroidPositions[i * 3] = centroids[i][0];
                centroidPositions[i * 3 + 1] = centroids[i][1];
                centroidPositions[i * 3 + 2] = centroids[i][2];
                
                const color = new THREE.Color(clusterColors[i % clusterColors.length]);
                centroidColors[i * 3] = color.r;
                centroidColors[i * 3 + 1] = color.g;
                centroidColors[i * 3 + 2] = color.b;
            }
            
            centroidGeometry.setAttribute('position', new THREE.BufferAttribute(centroidPositions, 3));
            centroidGeometry.setAttribute('color', new THREE.BufferAttribute(centroidColors, 3));
            
            const centroidMaterial = new THREE.PointsMaterial({
                size: pointSize * 3,
                vertexColors: true,
                sizeAttenuation: true
            });
            
            centroidsMesh = new THREE.Points(centroidGeometry, centroidMaterial);
            scene.add(centroidsMesh);
        }
    }
    
    function updateLegend(k) {
        const legend = document.getElementById('cluster-legend');
        legend.innerHTML = '';
        
        for (let i = 0; i < k; i++) {
            const item = document.createElement('div');
            item.className = 'cluster-item';
            
            const colorBox = document.createElement('div');
            colorBox.className = 'cluster-color';
            colorBox.style.background = `#${clusterColors[i].toString(16).padStart(6, '0')}`;
            
            const label = document.createElement('span');
            label.textContent = `C${i + 1}`;
            
            item.appendChild(colorBox);
            item.appendChild(label);
            legend.appendChild(item);
        }
    }
    
    // ====================================================================
    // CONTROLS
    // ====================================================================
    
    let config = {
        datasetType: 'gaussian',
        numPoints: 500,
        k: 3,
        algorithm: 'kmeans',
        pointSize: 0.03,
        rotationSpeed: 0.5,
        showCentroids: true
    };
    
    function regenerateData() {
        const type = config.datasetType;
        const n = config.numPoints;
        
        switch(type) {
            case 'gaussian':
                currentData = generateGaussianBlobs(n, config.k);
                break;
            case 'spiral':
                currentData = generateSpiral(n);
                break;
            case 'sphere':
                currentData = generateSphere(n);
                break;
            case 'swiss-roll':
                currentData = generateSwissRoll(n);
                break;
        }
        
        currentAssignments = new Array(currentData.length).fill(0);
        currentCentroids = [];
        visualizePoints(currentData, currentAssignments, currentCentroids, config.pointSize, config.showCentroids);
        
        document.getElementById('point-count').textContent = currentData.length;
        document.getElementById('cluster-count').textContent = 0;
    }
    
    function runClustering() {
        if (currentData.length === 0) return;
        
        const result = kMeans(currentData, config.k);
        currentAssignments = result.assignments;
        currentCentroids = result.centroids;
        
        visualizePoints(currentData, currentAssignments, currentCentroids, config.pointSize, config.showCentroids);
        updateLegend(config.k);
        
        document.getElementById('cluster-count').textContent = config.k;
        document.getElementById('algo-name').textContent = 'K-Means';
    }
    
    // Event listeners
    document.getElementById('dataset-type').addEventListener('change', (e) => {
        config.datasetType = e.target.value;
        regenerateData();
    });
    
    document.getElementById('points-slider').addEventListener('input', (e) => {
        config.numPoints = parseInt(e.target.value);
        document.getElementById('points-value').textContent = config.numPoints;
    });
    
    document.getElementById('k-slider').addEventListener('input', (e) => {
        config.k = parseInt(e.target.value);
        document.getElementById('k-value').textContent = config.k;
    });
    
    document.getElementById('size-slider').addEventListener('input', (e) => {
        config.pointSize = parseFloat(e.target.value);
        document.getElementById('size-value').textContent = config.pointSize.toFixed(2);
        visualizePoints(currentData, currentAssignments, currentCentroids, config.pointSize, config.showCentroids);
    });
    
    document.getElementById('rotation-slider').addEventListener('input', (e) => {
        config.rotationSpeed = parseFloat(e.target.value);
        document.getElementById('rotation-value').textContent = config.rotationSpeed.toFixed(1);
    });
    
    document.getElementById('centroids-toggle').addEventListener('change', (e) => {
        config.showCentroids = e.target.value === 'true';
        visualizePoints(currentData, currentAssignments, currentCentroids, config.pointSize, config.showCentroids);
    });
    
    document.getElementById('regenerate-btn').addEventListener('click', regenerateData);
    document.getElementById('cluster-btn').addEventListener('click', runClustering);
    
    // ====================================================================
    // ANIMATION LOOP
    // ====================================================================
    
    let lastTime = performance.now();
    let frameCount = 0;
    
    function animate() {
        requestAnimationFrame(animate);
        
        // Rotate scene
        if (pointsMesh) {
            pointsMesh.rotation.y += 0.001 * config.rotationSpeed;
        }
        if (centroidsMesh) {
            centroidsMesh.rotation.y += 0.001 * config.rotationSpeed;
        }
        
        // FPS counter
        frameCount++;
        const now = performance.now();
        if (now - lastTime >= 1000) {
            document.getElementById('fps').textContent = frameCount;
            frameCount = 0;
            lastTime = now;
        }
        
        renderer.render(scene, camera);
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = (window.innerWidth - 320) / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth - 320, window.innerHeight);
    });
    
    // Initialize
    regenerateData();
    animate();
</script>
```

</body>
</html>