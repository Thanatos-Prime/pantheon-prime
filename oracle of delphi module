---

## 4. `oracle/oracle_delphi.py`

```python
"""
oracle_delphi.py

PantheonOS Oracle of Delphi Module v1.0

This module implements a structured, non-mystical oracle engine
for cross-domain idea generation.

It uses:
- Hogge Creativity Dice (HCD)      – controlled entropy
- Hogge Principle of Emergent Structure (HPES) – emergent coherence
- Evolutionary Insulated Umbrella (EIU)        – safe incubation

All imports referring to PantheonOS internals are kept as optional/stubbed,
so this file is usable as a standalone creative utility.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Callable
import random
import math


# ====== DATA CLASSES ======


@dataclass
class OracleConfig:
    """
    Configuration for the Oracle of Delphi.
    """
    entropy: float = 0.4              # 0.0 (safe) .. 1.0 (wild)
    max_ideas: int = 5
    theme: Optional[str] = None
    enable_debug: bool = False
    seed: Optional[int] = None

    # Optional external hooks for integration with full PantheonOS
    filter_hook: Optional[Callable[[Dict[str, Any]], bool]] = None
    score_hook: Optional[Callable[[Dict[str, Any]], float]] = None


@dataclass
class OracleIdea:
    """
    A single structured idea generated by the Oracle.
    """
    title: str
    description: str
    rationale: str
    possible_next_steps: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class OracleResponse:
    """
    Full response from an Oracle consultation.
    """
    question: str
    summary: str
    ideas: List[OracleIdea]
    angles: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    debug: Dict[str, Any] = field(default_factory=dict)


# ====== CORE ORACLE CLASS ======


class OracleOfDelphi:
    """
    Main Oracle engine.

    Usage:
        config = OracleConfig(entropy=0.42, max_ideas=5, theme="AI + creativity")
        oracle = OracleOfDelphi(config)
        response = oracle.consult("How can PantheonOS be used in film production?")
    """

    def __init__(self, config: OracleConfig):
        self.config = config
        if config.seed is not None:
            random.seed(config.seed)

    # ---- Public API ----

    def consult(self, question: str) -> OracleResponse:
        """
        Public entrypoint. Given a question, returns an OracleResponse.
        """
        qframe = self._normalize_query(question)
        candidates, debug_info = self._generate_candidates(qframe)
        structured_ideas = self._filter_and_structure(candidates, qframe)
        response = self._assemble_response(question, qframe, structured_ideas, debug_info)
        return response

    # ---- Internal Steps ----

    def _normalize_query(self, question: str) -> Dict[str, Any]:
        """
        Query Normalization Layer (QNL).
        Very lightweight heuristic parsing.
        """
        q_lower = question.lower()

        domain = None
        if any(k in q_lower for k in ["startup", "business", "market"]):
            domain = "business"
        elif any(k in q_lower for k in ["story", "screenplay", "film", "movie"]):
            domain = "narrative"
        elif any(k in q_lower for k in ["research", "paper", "experiment"]):
            domain = "research"
        else:
            domain = "general"

        tone = "exploratory"
        if any(k in q_lower for k in ["risk", "threat", "attack", "defense"]):
            tone = "strategic"

        qframe = {
            "raw": question,
            "domain": domain,
            "tone": tone,
            "theme": self.config.theme,
        }
        return qframe

    def _generate_candidates(self, qframe: Dict[str, Any]) -> (List[Dict[str, Any]], Dict[str, Any]):
        """
        Creative Expansion Layer (CEL).
        Uses a simplified Hogge Creativity Dice model to generate candidate idea seeds.
        """
        num_rolls = max(self.config.max_ideas * 2, 6)
        candidates = []
        debug_rolls = []

        for i in range(num_rolls):
            face = self._roll_creativity_face()
            seed = self._sample_noise()
            idea_seed = self._apply_face_to_query(qframe, face, seed)
            candidates.append(idea_seed)

            if self.config.enable_debug:
                debug_rolls.append({
                    "index": i,
                    "face": face,
                    "seed": seed,
                    "idea_seed": idea_seed,
                })

        debug_info = {"dice_rolls": debug_rolls} if self.config.enable_debug else {}
        return candidates, debug_info

    def _filter_and_structure(self, candidates: List[Dict[str, Any]], qframe: Dict[str, Any]) -> List[OracleIdea]:
        """
        Emergent Structuring Layer (ESL).
        Applies basic filtering and scoring (HPES-inspired).
        """
        scored: List[(float, Dict[str, Any])] = []

        for c in candidates:
            if not self._passes_basic_filters(c):
                continue

            score = self._score_candidate(c, qframe)
            scored.append((score, c))

        # Sort by score descending and trim
        scored.sort(key=lambda t: t[0], reverse=True)
        top = scored[: self.config.max_ideas]

        structured: List[OracleIdea] = []
        for score, c in top:
            structured.append(self._candidate_to_idea(c, score))

        return structured

    def _assemble_response(
        self,
        question: str,
        qframe: Dict[str, Any],
        ideas: List[OracleIdea],
        debug_info: Dict[str, Any],
    ) -> OracleResponse:
        """
        Response Assembly Layer (RAL).
        """
        if ideas:
            summary = f"The Oracle generated {len(ideas)} structured idea(s) about: {question}"
        else:
            summary = f"The Oracle did not find strong candidates for: {question}. Try lowering constraints or entropy."

        angles = self._generate_angles(qframe)
        warnings = []

        warnings.append(
            "This Oracle is a creativity engine, not a predictive system. "
            "Use judgment, ethics, and real-world constraints for any implementation."
        )

        return OracleResponse(
            question=question,
            summary=summary,
            ideas=ideas,
            angles=angles,
            warnings=warnings,
            debug=debug_info,
        )

    # ====== Creativity Dice Helpers ======

    def _roll_creativity_face(self) -> str:
        """
        Simplified Hogge Creativity Dice with dynamic weighting.
        Faces: mutate, fuse, reduce, expand, echo, wildcard
        """
        entropy = max(0.0, min(1.0, self.config.entropy))

        faces = ["mutate", "fuse", "reduce", "expand", "echo", "wildcard"]
        # Simple weighting - more entropy tilts towards fuse/wildcard
        weights = [
            0.18 * (1 - entropy),  # mutate
            0.22 * (0.5 + entropy),
            0.14 * (1 - entropy),
            0.20,
            0.16,
            0.10 * (0.5 + entropy),
        ]
        total = sum(weights)
        norm_weights = [w / total for w in weights]

        r = random.random()
        cum = 0.0
        for face, w in zip(faces, norm_weights):
            cum += w
            if r <= cum:
                return face
        return faces[-1]

    def _sample_noise(self) -> float:
        """
        Sample noise using a simple mixture: normal + occasional heavy tail.
        """
        if random.random() < self.config.entropy:
            # heavy tail / wild
            return math.tan((random.random() - 0.5) * math.pi * 0.8)
        else:
            # mild normal
            return random.gauss(0.0, 1.0)

    def _apply_face_to_query(self, qframe: Dict[str, Any], face: str, seed: float) -> Dict[str, Any]:
        """
        Map a dice face + seed + query into a candidate concept description.
        This is deliberately lightweight and textual.
        """
        base_topic = qframe.get("raw", "")
        domain = qframe.get("domain", "general")
        theme = qframe.get("theme") or "general creativity"

        # Very lightweight templates:
        if face == "mutate":
            mode = "variation on existing concept"
        elif face == "fuse":
            mode = "fusion of the core topic with an unexpected second domain"
        elif face == "reduce":
            mode = "minimalist, essential version of the core idea"
        elif face == "expand":
            mode = "system-level expansion of the idea"
        elif face == "echo":
            mode = "self-similar echo at a different scale (micro/macro)"
        else:  # wildcard
            mode = "unconventional or counter-intuitive twist"

        return {
            "face": face,
            "seed": seed,
            "mode": mode,
            "base_topic": base_topic,
            "domain": domain,
            "theme": theme,
        }

    # ====== Filtering & Scoring ======

    def _passes_basic_filters(self, c: Dict[str, Any]) -> bool:
        """
        Basic sanity filters. Hook point for EIU and Arctic Framework in full PantheonOS.
        """
        # External hook first, if provided
        if self.config.filter_hook is not None:
            return bool(self.config.filter_hook(c))

        # Simple default filters: require base topic and mode
        if not c.get("base_topic"):
            return False
        if not c.get("mode"):
            return False
        return True

    def _score_candidate(self, c: Dict[str, Any], qframe: Dict[str, Any]) -> float:
        """
        Score a candidate for HPES-like emergent quality.
        """
        if self.config.score_hook is not None:
            return float(self.config.score_hook(c))

        # Simple heuristic scoring:
        score = 0.0

        # Give a slight bump to fusion & expand (emergent structure potential)
        if c["face"] in ("fuse", "expand"):
            score += 0.4
        elif c["face"] in ("echo", "mutate"):
            score += 0.3
        else:
            score += 0.2

        # Entropy influence – moderate entropy yields higher diversity reward
        entropy = max(0.0, min(1.0, self.config.entropy))
        score += 0.2 * (0.5 - abs(entropy - 0.5))  # peak around 0.5

        # Domain alignment bump (if theme matches)
        theme = self.config.theme or ""
        if theme and theme.lower() in c["base_topic"].lower():
            score += 0.1

        # Add small random jitter for tie-breaking
        score += random.uniform(0.0, 0.1)

        return score

    def _candidate_to_idea(self, c: Dict[str, Any], score: float) -> OracleIdea:
        """
        Convert internal candidate dict into OracleIdea structure.
        """
        face = c.get("face", "unknown")
        mode = c.get("mode", "")
        base_topic = c.get("base_topic", "")
        domain = c.get("domain", "general")
        theme = c.get("theme", "general creativity")

        title = f"[{face.upper()}] {self._shorten_text(base_topic, 60)}"
        description = (
            f"This idea was generated in '{mode}' mode for the topic:\n"
            f"  \"{base_topic}\"\n\n"
            f"Domain: {domain}\n"
            f"Theme: {theme}\n\n"
            f"It is intended as a creative angle, not as advice or prediction."
        )

        rationale = (
            "Selected by the Oracle for its potential to generate emergent structure "
            "under the Hogge Principle, given the current entropy and configuration."
        )

        possible_next_steps = [
            "Write a one-page pitch expanding this angle.",
            "List three concrete use-cases based on this idea.",
            "Identify one domain that could be fused with this idea for further exploration.",
        ]

        metadata = {
            "score": score,
            "face": face,
            "domain": domain,
            "theme": theme,
            "seed": c.get("seed"),
        }

        return OracleIdea(
            title=title,
            description=description,
            rationale=rationale,
            possible_next_steps=possible_next_steps,
            metadata=metadata,
        )

    # ====== Helpers ======

    @staticmethod
    def _shorten_text(text: str, max_len: int) -> str:
        if len(text) <= max_len:
            return text
        return text[: max_len - 3] + "..."

    def _generate_angles(self, qframe: Dict[str, Any]) -> List[str]:
        """
        Generate high-level 'angles' for the user to think from.
        """
        domain = qframe.get("domain", "general")
        raw = qframe.get("raw", "")

        angles = [
            f"Reframe the question from the perspective of a different stakeholder.",
            f"Ask: what happens if we invert the premise of: \"{self._shorten_text(raw, 80)}\"?",
        ]

        if domain == "narrative":
            angles.append("Consider mapping your question onto a 3-act or hero's-journey structure.")
        elif domain == "business":
            angles.append("Frame the question as a value-flow or game-theory problem.")
        elif domain == "research":
            angles.append("Try expressing the question as a falsifiable hypothesis or experiment.")

        return angles