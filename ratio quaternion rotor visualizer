import React, { useEffect, useRef, useState } from ‘react’;

// ============================================================
// QUATERNION MATH LIBRARY
// ============================================================

const quat = (w, x, y, z) => ({ w, x, y, z });

const quatAdd = (a, b) => quat(
a.w + b.w, a.x + b.x, a.y + b.y, a.z + b.z
);

const quatMul = (a, b) => quat(
a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
);

const quatConj = (q) => quat(q.w, -q.x, -q.y, -q.z);

const quatNorm = (q) =>
Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);

const quatNormalize = (q) => {
const n = quatNorm(q) || 1.0;
return quat(q.w/n, q.x/n, q.y/n, q.z/n);
};

const quatExpPure = (vx, vy, vz) => {
const theta = Math.sqrt(vx*vx + vy*vy + vz*vz);
if (theta < 1e-8) return quat(1, 0, 0, 0);
const s = Math.sin(theta) / theta;
return quat(Math.cos(theta), vx * s, vy * s, vz * s);
};

const quatRotateVector = (q, v) => {
const p = quat(0, v[0], v[1], v[2]);
const qConj = quatConj(q);
const r = quatMul(quatMul(q, p), qConj);
return [r.x, r.y, r.z];
};

// ============================================================
// HOGGE → QUATERNION MAPPING
// ============================================================

const buildHoggeQuaternion = (state, context) => {
const dt = state.t - context.t;
const dz = state.z - context.z;
const de = state.e - context.e;
const dn = state.n - context.n;
const dl = state.l - context.l;

// Map to 3D rotor: t→x, z→y, (e+n)→z
const vx = dt;
const vy = dz;
const vz = de + dn * 0.5; // fold narrative into energy axis

const rotor = quatExpPure(vx, vy, vz);

return {
rotor,
ethicalDelta: dl,
narrativeDelta: dn,
magnitude: Math.sqrt(vx*vx + vy*vy + vz*vz)
};
};

// ============================================================
// WEBGL VISUALIZATION COMPONENT
// ============================================================

const HoggeRotorVisualizer = () => {
const canvasRef = useRef(null);
const [state, setState] = useState({ t: 0, z: 0, e: 0, n: 0, l: 0 });
const [context, setContext] = useState({ t: 0, z: 0, e: 0, n: 0, l: 0 });
const [mode, setMode] = useState(‘neutral’); // ‘neutral’, ‘context’, ‘bidirectional’

useEffect(() => {
const canvas = canvasRef.current;
const gl = canvas.getContext(‘webgl’);
if (!gl) {
alert(‘WebGL not supported’);
return;
}

```
// Shaders
const vsSrc = `
  attribute vec3 aPosition;
  uniform mat4 uProj;
  void main() {
    gl_Position = uProj * vec4(aPosition, 1.0);
  }
`;

const fsSrc = `
  precision mediump float;
  uniform vec3 uColor;
  void main() {
    gl_FragColor = vec4(uColor, 1.0);
  }
`;

const compileShader = (type, src) => {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
};

const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);

gl.useProgram(prog);

const aPosition = gl.getAttribLocation(prog, 'aPosition');
const uProj = gl.getUniformLocation(prog, 'uProj');
const uColor = gl.getUniformLocation(prog, 'uColor');

const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

const makePerspective = (fov, aspect, near, far) => {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  return new Float32Array([
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)*nf, -1,
    0, 0, (2*far*near)*nf, 0
  ]);
};

let frameId;
const render = () => {
  const effectiveContext = mode === 'neutral' 
    ? { t: 0, z: 0, e: 0, n: 0, l: 0 }
    : context;

  const { rotor, ethicalDelta, narrativeDelta, magnitude } = 
    buildHoggeQuaternion(state, effectiveContext);

  gl.clearColor(0.02, 0.04, 0.08, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.width / canvas.height;
  const proj = makePerspective(Math.PI / 3, aspect, 0.1, 10.0);
  proj[14] -= 3.0; // camera distance

  gl.uniformMatrix4fv(uProj, false, proj);

  // Base vectors
  const baseX = [1, 0, 0];
  const baseY = [0, 1, 0];
  const baseZ = [0, 0, 1];

  // Rotated vectors
  const rotX = quatRotateVector(rotor, baseX);
  const rotY = quatRotateVector(rotor, baseY);
  const rotZ = quatRotateVector(rotor, baseZ);

  const lines = [];

  // Draw basis frame (grey)
  lines.push(0, 0, 0, ...baseX, 0.4, 0.4, 0.4);
  lines.push(0, 0, 0, ...baseY, 0.4, 0.4, 0.4);
  lines.push(0, 0, 0, ...baseZ, 0.4, 0.4, 0.4);

  // Draw rotated frame (colored by ethics and narrative)
  const eMag = Math.min(Math.abs(ethicalDelta), 1.0);
  const nMag = Math.min(Math.abs(narrativeDelta), 1.0);
  
  const r = ethicalDelta > 0 ? 0.2 + 0.8 * eMag : 0.2;
  const g = ethicalDelta < 0 ? 0.2 + 0.8 * eMag : 0.2;
  const b = 0.3 + 0.7 * nMag;

  lines.push(0, 0, 0, ...rotX, r, g, b);
  lines.push(0, 0, 0, ...rotY, r * 0.8, g * 0.8, b * 0.8);
  lines.push(0, 0, 0, ...rotZ, r * 0.6, g * 0.6, b * 0.6);

  // Render all lines
  for (let i = 0; i < lines.length; i += 9) {
    const lineData = new Float32Array([
      lines[i], lines[i+1], lines[i+2],
      lines[i+3], lines[i+4], lines[i+5]
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, lineData, gl.DYNAMIC_DRAW);
    gl.uniform3f(uColor, lines[i+6], lines[i+7], lines[i+8]);
    gl.drawArrays(gl.LINES, 0, 2);
  }

  frameId = requestAnimationFrame(render);
};

const handleResize = () => {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
};

handleResize();
window.addEventListener('resize', handleResize);
render();

return () => {
  cancelAnimationFrame(frameId);
  window.removeEventListener('resize', handleResize);
};
```

}, [state, context, mode]);

const Slider = ({ label, value, onChange, color }) => (
<div className="flex items-center gap-2 mb-2">
<span className={`w-4 text-${color}-400 font-bold`}>{label}</span>
<input
type=“range”
min=”-2”
max=“2”
step=“0.01”
value={value}
onChange={(e) => onChange(parseFloat(e.target.value))}
className=“flex-1”
/>
<span className="w-12 text-right text-xs text-gray-400">
{value.toFixed(2)}
</span>
</div>
);

return (
<div className="w-full h-screen bg-gray-950 text-gray-100 flex">
<div className="w-80 p-4 bg-gray-900 overflow-y-auto border-r border-gray-800">
<h1 className="text-xl font-bold mb-4 text-cyan-400">
Hogge Ratio Rotor Visualizer
</h1>

```
    <div className="mb-4 p-3 bg-gray-800 rounded">
      <div className="text-sm mb-2 text-gray-300">Reference Frame:</div>
      <select 
        value={mode} 
        onChange={(e) => setMode(e.target.value)}
        className="w-full bg-gray-700 p-2 rounded"
      >
        <option value="neutral">Neutral → State</option>
        <option value="context">Context → State</option>
      </select>
    </div>

    <div className="mb-6">
      <h2 className="text-sm font-semibold mb-2 text-green-400">State |S⟩</h2>
      <Slider label="t" value={state.t} onChange={(v) => setState({...state, t: v})} color="red" />
      <Slider label="z" value={state.z} onChange={(v) => setState({...state, z: v})} color="yellow" />
      <Slider label="e" value={state.e} onChange={(v) => setState({...state, e: v})} color="blue" />
      <Slider label="n" value={state.n} onChange={(v) => setState({...state, n: v})} color="purple" />
      <Slider label="l" value={state.l} onChange={(v) => setState({...state, l: v})} color="pink" />
    </div>

    {mode === 'context' && (
      <div className="mb-6">
        <h2 className="text-sm font-semibold mb-2 text-orange-400">Context |C⟩</h2>
        <Slider label="t" value={context.t} onChange={(v) => setContext({...context, t: v})} color="red" />
        <Slider label="z" value={context.z} onChange={(v) => setContext({...context, z: v})} color="yellow" />
        <Slider label="e" value={context.e} onChange={(v) => setContext({...context, e: v})} color="blue" />
        <Slider label="n" value={context.n} onChange={(v) => setContext({...context, n: v})} color="purple" />
        <Slider label="l" value={context.l} onChange={(v) => setContext({...context, l: v})} color="pink" />
      </div>
    )}

    <div className="mt-6 p-3 bg-gray-800 rounded text-xs space-y-2">
      <div><strong className="text-cyan-400">Axes:</strong></div>
      <div><span className="text-red-400">t</span> = timing</div>
      <div><span className="text-yellow-400">z</span> = zero-type (nullity)</div>
      <div><span className="text-blue-400">e</span> = energy</div>
      <div><span className="text-purple-400">n</span> = narrative density</div>
      <div><span className="text-pink-400">l</span> = ethical load</div>
      <div className="mt-3 text-gray-400">
        Grey vectors = basis frame<br/>
        Colored vectors = rotated frame<br/>
        Color intensity = ethical tension
      </div>
    </div>
  </div>

  <div className="flex-1 relative">
    <canvas 
      ref={canvasRef} 
      className="w-full h-full"
      style={{ display: 'block' }}
    />
  </div>
</div>
```

);
};

export default HoggeRotorVisualizer;