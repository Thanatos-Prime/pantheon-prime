#!/usr/bin/env python3

# Hogge-Zero Codex: Three Fundamental Approaches

# 1. PHYSICAL SPACE: 0s and 1s as physical stand-ins for letter forms

# 2. HOGGE SIEVE: Ignore 1s, read only zeros (filter out noise)

# 3. HYBRID BASTARD: Both methods simultaneously on same line

# ============================================================================

# APPROACH 1: PHYSICAL SPACE ENCODING

# Each 0 or 1 physically represents a letter’s form/structure

# The digit itself + its position = the encoded letter

# ============================================================================

def encode_physical_space(message):
“””
Map each letter to a binary pattern based on its structure.
A=0, B=1, C=00, D=01, E=10, F=11, G=000, etc.
The physical arrangement of 0s and 1s IS the letter.
“””
# Simple mapping: letter position in alphabet to binary
letter_to_binary = {}
for i, letter in enumerate(‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’):
letter_to_binary[letter] = format(i, ‘05b’)  # 5-bit binary
letter_to_binary[’ ‘] = ‘11111’  # Space marker
letter_to_binary[’,’] = ‘11110’  # Comma marker

```
# Encode
encoded_bits = []
for char in message.upper():
    if char in letter_to_binary:
        encoded_bits.append(letter_to_binary[char])

encoded = ''.join(encoded_bits)

# Decode
decoded = []
for i in range(0, len(encoded), 5):
    chunk = encoded[i:i+5]
    if chunk == '11111':
        decoded.append(' ')
    elif chunk == '11110':
        decoded.append(',')
    else:
        letter_idx = int(chunk, 2)
        if letter_idx < 26:
            decoded.append(chr(65 + letter_idx))

return encoded, ''.join(decoded), letter_to_binary
```

# ============================================================================

# APPROACH 2: HOGGE SIEVE

# The 1s are NOISE/DECOY - only the 0s carry meaning

# Read the line, filter out all 1s, decode from zero patterns

# ============================================================================

def encode_hogge_sieve(message, noise_ratio=0.4):
“””
Encode message in zero positions only.
1s are inserted as noise/camouflage.
To decode: filter out all 1s, read only the 0-pattern.
“””
import random

```
# Map letters to zero patterns (using gaps between zeros)
# Pattern = number of positions to next zero
letter_to_gap = {}
for i, letter in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ'):
    letter_to_gap[letter] = (i % 10) + 1  # Gaps of 1-10
letter_to_gap[' '] = 11
letter_to_gap[','] = 12

# Encode with gaps
encoded = []
for char in message.upper():
    if char in letter_to_gap:
        gap = letter_to_gap[char]
        # Add (gap-1) ones, then a zero
        encoded.extend(['1'] * (gap - 1))
        encoded.append('0')

# Add random 1s for extra noise (optional)
if noise_ratio > 0:
    noise_count = int(len(encoded) * noise_ratio)
    for _ in range(noise_count):
        pos = random.randint(0, len(encoded))
        encoded.insert(pos, '1')

encoded_str = ''.join(encoded)

# Decode: find zero positions, measure gaps
zero_positions = [i for i, bit in enumerate(encoded_str) if bit == '0']

decoded = []
for i in range(len(zero_positions)):
    if i == 0:
        gap = zero_positions[0] + 1
    else:
        gap = zero_positions[i] - zero_positions[i-1]
    
    # Find letter with this gap
    for letter, g in letter_to_gap.items():
        if g == gap:
            decoded.append(letter)
            break

return encoded_str, ''.join(decoded), zero_positions
```

# ============================================================================

# APPROACH 3: HYBRID BASTARD

# Same binary line encodes TWO messages:

# - Message 1: Read as normal binary (physical space method)

# - Message 2: Filter 1s, read only zeros (Hogge sieve method)

# One line, two completely different messages!

# ============================================================================

def encode_hybrid_bastard(message1, message2):
“””
Encode TWO messages in the same binary string.
Message 1: Standard binary encoding (all digits matter)
Message 2: Hidden in zero positions (ignore 1s)
“””
# Start with message 1 (physical space encoding)
primary_encoded, _, _ = encode_physical_space(message1)

```
# Now strategically place zeros to encode message 2
# We'll insert additional bits to create the right zero-pattern

# Map message 2 to desired zero positions
letter_to_zerocode = {}
for i, letter in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ'):
    # Each letter defines a pattern of where to place zeros
    letter_to_zerocode[letter] = i % 8  # 0-7 positions apart
letter_to_zerocode[' '] = 8
letter_to_zerocode[','] = 9

# Create hybrid by interleaving
hybrid = list(primary_encoded)

# Track where we place zeros for message 2
zero_insertions = []
current_pos = 0

for char in message2.upper():
    if char in letter_to_zerocode:
        pattern = letter_to_zerocode[char]
        target_pos = current_pos + pattern + 1
        
        # Ensure we don't go out of bounds
        while target_pos >= len(hybrid):
            hybrid.append('1')  # Pad with 1s
        
        # Place a zero at target position
        hybrid[target_pos] = '0'
        zero_insertions.append(target_pos)
        current_pos = target_pos

hybrid_str = ''.join(hybrid)

# Decode message 1 (treat as normal binary)
decoded1 = []
for i in range(0, min(len(hybrid_str), len(message1)*5), 5):
    chunk = hybrid_str[i:i+5]
    if len(chunk) == 5:
        val = int(chunk, 2)
        if val == 31:
            decoded1.append(' ')
        elif val == 30:
            decoded1.append(',')
        elif val < 26:
            decoded1.append(chr(65 + val))

# Decode message 2 (read only zero positions)
zero_positions = [i for i, bit in enumerate(hybrid_str) if bit == '0']
decoded2 = []

for i in range(len(zero_positions) - 1):
    gap = zero_positions[i+1] - zero_positions[i]
    pattern = (gap - 1) % 10
    if pattern < 26:
        decoded2.append(chr(65 + pattern))

return hybrid_str, ''.join(decoded1), ''.join(decoded2), zero_insertions
```

# ============================================================================

# VISUAL DEMONSTRATION

# ============================================================================

def visualize_encoding(binary_str, zero_positions=None, title=””):
“”“Show the binary with zeros highlighted.”””
print(f”\n{title}”)
print(“─” * 80)

```
# Show binary
print("Binary: ", end="")
for i, bit in enumerate(binary_str):
    if bit == '0':
        print(f"\033[1;32m{bit}\033[0m", end="")  # Green zeros
    else:
        print(f"\033[90m{bit}\033[0m", end="")    # Gray ones
print()

# Show positions
print("Pos:    ", end="")
for i in range(len(binary_str)):
    print(i % 10, end="")
print()

# Highlight zero positions if provided
if zero_positions:
    print("Zeros:  ", end="")
    for i in range(len(binary_str)):
        if i in zero_positions:
            print("^", end="")
        else:
            print(" ", end="")
    print()
```

# ============================================================================

# DEMO ALL THREE APPROACHES

# ============================================================================

print(”=” * 80)
print(“HOGGE-ZERO CODEX: Three Fundamental Approaches”)
print(”=” * 80)

# Test messages

MSG1 = “HELLO”
MSG2 = “WORLD”

print(”\n” + “█” * 80)
print(“APPROACH 1: PHYSICAL SPACE”)
print(“Each 0 and 1 physically represents a letter structure”)
print(“█” * 80)

encoded, decoded, mapping = encode_physical_space(MSG1)
print(f”\nMessage: {MSG1}”)
print(f”Encoded: {encoded}”)
print(f”Decoded: {decoded}”)
print(f”\nLetter mappings (sample):”)
for letter in MSG1:
if letter in mapping:
print(f”  {letter} → {mapping[letter]}”)
visualize_encoding(encoded, title=“Visual representation:”)

print(”\n” + “█” * 80)
print(“APPROACH 2: HOGGE SIEVE”)
print(“Filter out all 1s (noise), read only the zero-pattern”)
print(“█” * 80)

encoded, decoded, zero_pos = encode_hogge_sieve(MSG1, noise_ratio=0.3)
print(f”\nMessage: {MSG1}”)
print(f”Encoded: {encoded}”)
print(f”Decoded: {decoded}”)
print(f”Zero positions: {zero_pos}”)
print(f”\n*** KEY INSIGHT: Ignore all 1s! ***”)
print(f”The zeros alone encode: {decoded}”)
visualize_encoding(encoded, zero_pos, title=“Visual (zeros highlighted):”)

print(”\n” + “█” * 80)
print(“APPROACH 3: HYBRID BASTARD”)
print(“ONE line encodes TWO messages - read it two different ways!”)
print(“█” * 80)

hybrid, decoded1, decoded2, zero_ins = encode_hybrid_bastard(MSG1, MSG2)
print(f”\nMessage 1 (physical): {MSG1}”)
print(f”Message 2 (sieve):    {MSG2}”)
print(f”\nHybrid encoding: {hybrid}”)
print(f”\nDecoded as physical space: {decoded1}”)
print(f”Decoded via Hogge sieve:   {decoded2}”)
print(f”\n*** DOUBLE MESSAGE: Same line, two readings! ***”)
visualize_encoding(hybrid, zero_ins, title=“Visual (Message 2 zeros marked):”)

print(”\n” + “=” * 80)
print(“SUMMARY”)
print(”=” * 80)
print(“1. PHYSICAL SPACE: 0s and 1s are letter structures (00101 = letter)”)
print(“2. HOGGE SIEVE:    1s are noise, only zeros matter (sieve out 1s)”)
print(“3. HYBRID BASTARD: Both methods on same line (two messages!)”)
print(”\nThe Hogge Equilibrium: All paths lead to zero, but encode infinity.”)
print(”=” * 80)