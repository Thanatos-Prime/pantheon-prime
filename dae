from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any, Dict
from .invariants import InvariantScores
from .state_vector import StateVector


class Daemon(ABC):
    """
    Minimal daemon contract.

    A daemon inspects:
      - current StateVector
      - proposed action

    and emits partial InvariantScores.

    The kernel later aggregates across daemons.
    """

    name: str = "daemon"

    @abstractmethod
    def evaluate(self, state: StateVector, action: Dict[str, Any]) -> InvariantScores:
        ...


class MirrorDaemon(Daemon):
    """
    d_mirror — coherence + truthfulness heuristic.

    For v0.1 we just use a toy rule:
      - if description contains "???", reduce truthfulness & coherence.
    """

    name = "d_mirror"

    def evaluate(self, state: StateVector, action: Dict[str, Any]) -> InvariantScores:
        description = action.get("description", "")
        looks_hallucinatory = "???" in description
        coherence = 0.3 if looks_hallucinatory else 1.0
        truthfulness = 0.5 if looks_hallucinatory else 1.0
        return InvariantScores(
            truthfulness=truthfulness,
            coherence=coherence,
            safety=1.0,
            privacy=1.0,
        )


class HoundDaemon(Daemon):
    """
    d_hound — risk/safety heuristic.

    Uses a simple label-based rule for now:
      risk = "low"    -> safety = 1.0
      risk = "medium" -> safety = 0.7
      risk = "high"   -> safety = 0.2
    """

    name = "d_hound"

    def evaluate(self, state: StateVector, action: Dict[str, Any]) -> InvariantScores:
        risk_label = action.get("risk", "low")
        if risk_label == "high":
            safety = 0.2
        elif risk_label == "medium":
            safety = 0.7
        else:
            safety = 1.0

        return InvariantScores(
            truthfulness=1.0,
            safety=safety,
            privacy=1.0,
            coherence=1.0,
        )