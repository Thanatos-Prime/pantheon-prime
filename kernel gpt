from __future__ import annotations
from typing import Any, Dict, List, Optional
import time
from .state_vector import StateVector
from .thought_object import ThoughtObject
from .invariants import InvariantAggregator, InvariantScores
from .daemons import Daemon


class PantheonKernel:
    """
    PantheonOS Kernel v0.1

    Responsibilities:
      - maintain hash-chained StateVector
      - emit hash-chained ThoughtObjects
      - collect daemon scores, compute ΣC
      - block/allow actions based on ΣC ≥ C_min
      - update state when allowed

    This is the minimal, runnable instantiation of the PantheonOS kernel.
    """

    def __init__(
        self,
        daemons: List[Daemon],
        aggregator: InvariantAggregator,
        origin_model: str = "pantheon-kernel-v0.1",
    ):
        self.daemons = daemons
        self.aggregator = aggregator
        self.origin_model = origin_model

        self.state = StateVector(data={})
        self._thought_chain: List[ThoughtObject] = []

    # --- Thought ledger helpers ---

    @property
    def last_thought_hash(self) -> Optional[str]:
        if not self._thought_chain:
            return None
        return self._thought_chain[-1].thought_hash

    def emit_thought(
        self,
        daemon_name: str,
        kind: str,
        payload: Dict[str, Any],
        tags: Optional[List[str]] = None,
    ) -> ThoughtObject:
        t_id = f"{int(time.time() * 1000)}-{len(self._thought_chain)}"
        thought = ThoughtObject(
            id=t_id,
            origin_model=self.origin_model,
            daemon=daemon_name,
            kind=kind,
            payload=payload,
            state_hash=self.state.state_hash,
            prev_thought_hash=self.last_thought_hash,
            tags=tags or [],
        )
        self._thought_chain.append(thought)
        return thought

    # --- Core API ---

    def propose_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """
        Run ΣC across all daemons, decide whether an action is allowed,
        and if allowed, update the StateVector and emit ThoughtObjects.

        Returns a structured result dict for logging / benchmarking / UI.
        """
        combined_scores = InvariantScores(
            truthfulness=1.0,
            safety=1.0,
            privacy=1.0,
            coherence=1.0,
        )
        daemon_contributions: Dict[str, Dict[str, float]] = {}

        # Each daemon contributes partial scores; we combine via min per dimension
        for d in self.daemons:
            scores = d.evaluate(self.state, action)
            daemon_contributions[d.name] = scores.as_dict()

            for dim, value in scores.as_dict().items():
                current = getattr(combined_scores, dim)
                setattr(combined_scores, dim, min(current, value))

        sigma_c = self.aggregator.compute_sigma_c(combined_scores)
        allowed = self.aggregator.is_allowed(combined_scores)

        # Log invariant evaluation
        self.emit_thought(
            daemon_name="kernel",
            kind="invariant_evaluation",
            payload={
                "action": action,
                "combined_scores": combined_scores.as_dict(),
                "daemon_contributions": daemon_contributions,
                "sigma_c": sigma_c,
                "allowed": allowed,
            },
            tags=["sigma_c", "gate"],
        )

        # If allowed, apply state patch and log state update
        if allowed:
            patch = action.get("state_patch", {})
            self.state = self.state.next(patch=patch)

            self.emit_thought(
                daemon_name="kernel",
                kind="action_applied",
                payload={"patch": patch, "new_state_hash": self.state.state_hash},
                tags=["action", "state_update"],
            )

        return {
            "allowed": allowed,
            "sigma_c": sigma_c,
            "scores": combined_scores.as_dict(),
            "daemon_contributions": daemon_contributions,
            "state_hash": self.state.state_hash,
        }

    def get_thought_chain(self) -> List[ThoughtObject]:
        """
        Return the current ThoughtObject chain (immutable snapshot list).
        """
        return list(self._thought_chain)