# Prime–Zero Field v1.0  
### A Structural Field Theory of Primes, Residues, and Composite “Molecules”

**Author:** PantheonOS Research Group  
**Version:** 1.0  
**Date:** 2025-11-23  
**Keywords:** prime-zero field, prime chemistry, residue geometry, number manifold, PantheonOS

---

## 0. Abstract

The **Prime–Zero Field (PZF)** is a conceptual and mathematical framework that treats:

- **primes** as “atoms”  
- **composites** as “molecules”  
- **zero-residue structures** as stabilizing bonds  
- and the integers as a **field-like medium** with distinct phases (prime vs composite)

The PZF is not a literal field in the strict algebraic sense; it is:

> A geometric–chemical metaphor rendered as a rigorous structure for reasoning about primes, residues, and factorization.

It aims to:

- visualize primes as a distributed “gas”  
- represent composites as clustered structures  
- use residue classes as **orbits**  
- define field-like quantities over number space  

---

## 1. Core Idea

Consider the set of positive integers:

$begin:math:display$
\\mathbb\{N\} \= \\\{1\, 2\, 3\, \\dots\\\}
$end:math:display$

Partitioned into:

- $begin:math:text$ \\mathcal\{P\} \= \\\{p \\in \\mathbb\{N\} \\mid p \\text\{ is prime\}\\\} $end:math:text$  
- $begin:math:text$ \\mathcal\{C\} \= \\\{n \\in \\mathbb\{N\} \\mid n \\text\{ composite\}\\\} $end:math:text$

We define a **Prime Indicator Function**:

$begin:math:display$
\\chi\_\{\\mathcal\{P\}\}\(n\) \=
\\begin\{cases\}
1\, \& n \\in \\mathcal\{P\} \\\\
0\, \& n \\notin \\mathcal\{P\}
\\end\{cases\}
$end:math:display$

and interpret:

- region where $begin:math:text$\\chi\_\{\\mathcal\{P\}\}\(n\)\=1$end:math:text$ as **prime phase**  
- region where $begin:math:text$\\chi\_\{\\mathcal\{P\}\}\(n\)\=0$end:math:text$ as **composite phase**  

The **Prime–Zero Field** assigns field-like values, densities, and potentials over this structure.

---

## 2. Prime Density and Field Intensity

Define the **local prime density** over an interval $begin:math:text$\[1\, x\]$end:math:text$:

$begin:math:display$
\\rho\_\{\\mathcal\{P\}\}\(x\) \= \\frac\{\\pi\(x\)\}\{x\}
$end:math:display$

where $begin:math:text$\\pi\(x\)$end:math:text$ is the prime counting function.

Heuristically, from the Prime Number Theorem:

$begin:math:display$
\\rho\_\{\\mathcal\{P\}\}\(x\) \\approx \\frac\{1\}\{\\log x\}
$end:math:display$

We interpret $begin:math:text$\\rho\_\{\\mathcal\{P\}\}\(x\)$end:math:text$ as:

- the “concentration” of prime atoms at scale $begin:math:text$x$end:math:text$  
- an **intensity** of prime field availability  

We can define a **Prime Intensity Field**:

$begin:math:display$
\\Phi\(x\) \= \\rho\_\{\\mathcal\{P\}\}\(x\)
$end:math:display$

---

## 3. Residue Classes as Orbits

For a fixed modulus $begin:math:text$m$end:math:text$, consider residue classes:

$begin:math:display$
\[n\]\_m \= \\\{ n \+ km \\mid k \\in \\mathbb\{Z\} \\\}
$end:math:display$

Within each class, we can examine **prime occupancy**:

$begin:math:display$
\\chi\_\{\\mathcal\{P\}\, m\, r\}\(k\) \=
\\begin\{cases\}
1\, \& n \= r \+ km \\in \\mathcal\{P\} \\\\
0\, \& \\text\{otherwise\}
\\end\{cases\}
$end:math:display$

This yields **patterns** like:

- primes favor certain residues mod $begin:math:text$m$end:math:text$ (e.g. $begin:math:text$6k \\pm 1$end:math:text$ for primes > 3)  
- composite “molecules” cluster differently  

We interpret each residue class as an **orbit in the prime-zero field**, with:

- **prime hits** as bright points  
- **gaps** as dark regions  

---

## 4. Prime–Zero Potential

We can define a **potential function** over $begin:math:text$\\mathbb\{N\}$end:math:text$:

$begin:math:display$
V\(n\) \= 
\\begin\{cases\}
V\_p\, \& n \\in \\mathcal\{P\} \\\\
V\_c\, \& n \\in \\mathcal\{C\}
\\end\{cases\}
$end:math:display$

with $begin:math:text$V\_p \< V\_c$end:math:text$, for example.

Or define:

$begin:math:display$
V\(n\) \= \-\\log\(\\log n\)
$end:math:display$

to reflect:

- primes become sparser as $begin:math:text$n$end:math:text$ grows  
- each prime is a “deep well” of structural information  

This potential can be used to model:

- how “surprising” a prime is at scale $begin:math:text$n$end:math:text$  
- how composites “sit” in a higher-energy environment  

---

## 5. Composite Molecules

If primes are atoms, composites are **prime molecules**.

For a composite $begin:math:text$n$end:math:text$:

$begin:math:display$
n \= \\prod\_\{i\=1\}\^k p\_i\^\{\\alpha\_i\}
$end:math:display$

We define a **Prime Composition Vector**:

$begin:math:display$
\\vec\{c\}\(n\) \= \(\\alpha\_1\, \\alpha\_2\, \\dots\, \\alpha\_k\)
$end:math:display$

and can interpret:

- the **L1 norm** $begin:math:text$\\\|\\vec\{c\}\(n\)\\\|\_1 \= \\sum\_i \\alpha\_i$end:math:text$ as “bond count”  
- the **L2 norm** $begin:math:text$\\\|\\vec\{c\}\(n\)\\\|\_2$end:math:text$ as a measure of “molecular complexity”  

We can define a **Complexity Function**:

$begin:math:display$
C\(n\) \= \\\|\\vec\{c\}\(n\)\\\|\_2\^2 \= \\sum\_i \\alpha\_i\^2
$end:math:display$

Simple composite (e.g. product of two distinct primes) → low $begin:math:text$C\(n\)$end:math:text$.  
Highly factored number → high $begin:math:text$C\(n\)$end:math:text$.

---

## 6. Prime–Zero Field as a Lattice

We can treat the integers as nodes in a graph:

- Node per integer $begin:math:text$n$end:math:text$  
- Edges between $begin:math:text$n$end:math:text$ and factors or multiples  
- Label primes vs composites  

This gives a **Prime–Zero Lattice**:

- primes = degree-2 nodes (connected to 1 and n, ignoring 1 as trivial)  
- composites = higher degree, more factor edges  

We can define a **field value** on each node:

$begin:math:display$
F\(n\) \= f\(\\chi\_\{\\mathcal\{P\}\}\(n\)\, C\(n\)\)
$end:math:display$

For example:

$begin:math:display$
F\(n\) \= \\chi\_\{\\mathcal\{P\}\}\(n\) \- \\lambda C\(n\)
$end:math:display$

Where $begin:math:text$\\lambda$end:math:text$ is a scaling factor.

---

## 7. Pseudocode: Prime–Zero Field Sampler

```python
"""
prime_zero_field.py

Pseudocode for exploring the Prime–Zero Field.
"""

from dataclasses import dataclass
from typing import List, Dict
import math

@dataclass
class NumberNode:
    n: int
    is_prime: bool
    factors: List[int]  # proper factors (excluding 1 and n)
    complexity: int     # C(n) = sum(alpha_i^2)
    field_value: float  # F(n)


def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0:
        return False
    k = 3
    while k * k <= n:
        if n % k == 0:
            return False
        k += 2
    return True


def prime_factorization(n: int) -> Dict[int, int]:
    """
    Returns a dict: prime -> exponent.
    """
    factors = {}
    d = 2
    nn = n
    while d * d <= nn:
        while nn % d == 0:
            factors[d] = factors.get(d, 0) + 1
            nn //= d
        d += 1 if d == 2 else 2  # small speedup: skip even > 2
    if nn > 1:
        factors[nn] = factors.get(nn, 0) + 1
    return factors


def complexity(n: int) -> int:
    """
    C(n) = sum(alpha_i^2)
    """
    if n < 2:
        return 0
    fac = prime_factorization(n)
    return sum(alpha * alpha for alpha in fac.values())


def prime_zero_field_value(n: int, lam: float = 0.5) -> float:
    """
    Example field value:
    F(n) = chi_P(n) - lam * C(n)
    """
    p = 1.0 if is_prime(n) else 0.0
    c = complexity(n)
    return p - lam * c


def build_prime_zero_lattice(N: int, lam: float = 0.5) -> List[NumberNode]:
    """
    Build a list of NumberNode objects for n = 2..N.
    """
    nodes: List[NumberNode] = []
    for n in range(2, N + 1):
        p = is_prime(n)
        # Proper factors (excluding 1 and n)
        fac_dict = prime_factorization(n)
        proper_factors = sorted(fac_dict.keys()) if not p else []
        c = complexity(n)
        fv = prime_zero_field_value(n, lam=lam)

        nodes.append(
            NumberNode(
                n=n,
                is_prime=p,
                factors=proper_factors,
                complexity=c,
                field_value=fv,
            )
        )
    return nodes